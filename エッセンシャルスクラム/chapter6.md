# 第6章：プロダクトバックログ

## プロダクトバックログとは
* プロダクトバックログとは、プロダクトに求められる機能と優先順位をつけてリスト化したもの
* これから何を作るのか、どの順番で作るのかを共有する
* プロダクトバックログは、複数のアイテムで構成される

## プロダクトバックログアイテム（PBI）

* PBIの例
    * フィーチャー
        * 新しい機能の追加
    * 変更
        * 既存のプロダクトのフィーチャーを少し修正
    * 不具合対応
        * 本番環境における障害の修正
    * 技術的な改善
        * データベースのメジャーバージョンアップ対応
    * 知識の獲得
        * アーキテクチャやプロトタイプ、PoCによる適切なアプローチの探索

## よいプロダクトバックログの特徴
DEEP（Picher(2010), Mike Cohn）
* 適切な詳細度（Detailed appropriately）
    * PBIが同じタイミングで同程度の詳細度になることはない
    * 小さいPBI
        * すぐに取り掛かる予定のPBIでバックログの先頭付近に集まる
        * サイズは小さめで、内容は詳細に書かれている
    * 大きいPBI
        * 作業の予定がたっておらず、バックログの奥の方にある
        * サイズは大きめで、詳細度は低い
    * 詳細度を上げるタイミング
        * 必要になったときにジャストインタイムでストーリーを切り分ける
        * 早く切りすぎると、詳細をまとめたのに、実装せず捨てることもあり得る
        * 切るのが遅れると、スプリントに割り当てる流れを止めてしまい、ベロシティが低下する
* 創発的（Emergent）
    * 時間と共に内容が変わっていく
        * PBIの変化の例
            * 新しいPBIの追加
            * 既存のPBIの更新、削除
        * PBIの変化の要因
            * 顧客のきまぐれ
            * 経済状況の変化
            * 競合他社の動向
            * 技術的問題
    * 内容が変わったら、プロダクトオーナーはバックログ全体を見直し、新しい情報に基づき、バランスを考えて優先順位付けをする
* 見積もり（Estimated）
    * PBIのアイテムのサイズは各アイテムの作業量を表す
    * 見積もった作業量をもとにプロダクトオーナーが優先順位付けをする
    * PBIの見積もりにはストーリーポイントまたは理想日を使う
    * 小さなPBIはサイズが小さめで詳細度も高いため見積もりは正確になるが、大きなPBIの見積もりは誤差が大きくなる
* 優先順位付け（Prioritized）
    * バックログ内のすべてのアイテムに優先順位付けされることはめったにない
    * 直近の数回のスプリント分のアイテムに優先順位付けが有用

## グルーミング
グルーミングとは、プロダクトバックログの中身（詳細、見積もり、優先順位）を整理していくこと

### グルーミングとは
グルーミングは以下のアクティビティを含む
* PBIの作成と改良（詳細の追加）、削除
* PBIの見積もり
* PBIの優先順位付け

### 誰がグルーミングするのか
* グルーミングはプロダクトオーナー主導で行う共同作業
* 開発チーム、スクラムマスターやその他のステークホルダーも参加する

### いつグルーミングするのか
* 前提：
    * グルーミングのタイミングは明確に定められていない
    * スクラムではもともと不確実性の高い環境を前提にしているため、常に見直しを意識しなければならない
* グルーミングのタイミング
    * リリースプランニング
    * スプリント内のグルーミングワークショップ
        * スプリントに一度程度の頻度で実施して予定を確保できる
    * デイリースクラム内
        * インクリメンタルなグルーミングを行う
        * 全員でやる必要はなく、対象のストーリーに詳しい人、興味を持った人がプロダクトオーナーとともに参加する
    * スプリントレビュー
        * プロダクトについて理解が深まるにつれて、新しいPBIを作ったり、既存のPBIの優先順位付けをやり直したり、不要なPBIを削除したりすることが多くなる

> [!NOTE]
> 
> :memo:コメント
> 
> よく誤解されがちなのが、グルーミング（もといリファインメント）はイベントじゃないので、各スクラムチームが各々のタイミングで適宜実施する必要がある。（Katsuya）
> > この本でもグルーミングは「3つのアクティビティの総称」と書かれていて、グルーミングはアクティビティと考えるのが（RyoyaC）
>

## 準備完了の定義
* グルーミングとは、バックログの先頭のアイテムを準備完了の状態にすること
    * つまり、開発チームがそれをスプリントに取り込めて、スプリントが終わるまでに作業を完了させられるとコミットできるような状態にすること
    * これをはっきりとするために「**準備完了の定義**」を定めているチームもある
* 準備完了の定義の例
    * ビジネス上の価値が明確になっている
    * 開発チームが詳細を十分に理解しており、PBIを完成させるかどうかを十分な情報に基づいて判断できる
    * 依存関係がはっきりわかっており、外部の依存関係のせいでこのPBIが完了できないということがない
    * PBIを完成させるためのチームを適切に割り当てられる
    * PBIの見積もりが済んでおり、1回のスプリントで完了させられる程度の大きさに収まっている
    * 受け入れ条件が明確になっており、テスト可能である
    * もしパフォーマンス要件があるのなら、それがきちんと定義されていて、かつテスト可能である
    * スクラムチームが、スプリントレビューでこのPBIの完了をどのように示せばいいのか理解している
    
> [!NOTE]
> 
> :memo:コメント
> 
> 準備完了の定義に「PBIを完成できるかどうかを、十分な情報に基づいて判断できる」という観点が含まれていて、Readyにする段階でフィージビリティの確認が必要だと理解できる一方、ある程度設計をしないとそのフィジ確認はできないのでは？とも思う。この段階でどこまでやれば良いのか疑問。（Katsuya）
>

## フローの管理
* リリースフローの管理
    * リリースに関してPBIの分類
        * 必須フィーチャー
            * リリースラインより上のアイテム
            * 次のリリースで必ず含めなければならないアイテム
            * このアイテムがなければ顧客にとって価値のあるリリースにならない
        * できれば含めたいフィーチャー
            * 1本目のリリースラインより下、2本目のリリースラインより上のアイテム
            * もし時間が足りなくて完成させられない場合は含めなくていいアイテム
            * 仮にこのフィーチャーがなくても価値のあるプロダクトとしてリリースできる
        * 含めないフィーチャー
            * 2本目のリリースラインより下
            * 次のリリースには含めないと決めたアイテム
* スプリントフローの管理
    * プロダクトバックログを要件のパイプラインと考えてグルーミングすることが有用
        * パイプラインの出口までにグルーミングされて、パイプラインから出てきたアイテムは準備完了の状態になっている
    * スプリント数回分のアイテムを準備完了状態にしておくと良い

## チーム、プロダクト、プロダクトバックログの関係
基本原則：プロダクトごとに1つプロダクトバックログを用意する

### プロダクトとは何か
* プロダクトの構成要素が明確でない
    * Wordは1つのプロダクトか、それともOfficeのうちの構成要素の1つか？
* プロダクトとは、何らかの価値をもたらすものであり、それのために対価を支払う価値があるとみなされるもの

### 大規模なプロダクトー階層化バックログ
* 大規模なチームでのプロダクトバックログ
    * 課題
        * 数十から百以上のチームのPBIをひとつのバックログにまとめるのは現実的ではない
    * 特徴
        * ジャンルの独立したチーム同士の、詳細化した作業内容のとりまとめや優先順位付けは他のジャンルと独立して行える
    * 対策
        * 階層化バックログを作り、大規模なバックログでの問題に対応している
* 階層化バックログ
    * 最上位のプロダクトバックログ
        * そのプロダクトの大規模なフィーチャー（エピック）を扱い、優先順位付けする
    * 下位のプロダクトバックログ
        * フィーチャージャンルごとに専用のプロダクトバックログをもつ

### 複数チームー単一のプロダクトバックログ
* すべてのチームの作業を一つのプロダクトバックログで扱えば、プロダクト全体で見て経済的な最適化ができる
* 理想
    * すべてのチームが交換可能（どのPBIも同じ期間、同じ品質で作れる）なら、単一バックログにおける優先順位付けのメリットが得られる
* 現実
    * 各チームがすべてのPBIに対応できるわけではない
    * そのうえで、各チームがどのPBIに対応できるか知っている必要がある
* 対策
    * チーム単位のプロダクトバックログを作るのではなく、共有バックログにチームごとのビューを用意する

### 単一チームー複数のプロダクト
* 複数のプロダクトバックログを扱うのに最適な方法は、プロダクトごとに専任のチームを割り当てること
    * しかし、一つのチームが複数のプロダクトバックログの作業を担当することもある
* 対策
    * 同時に複数のプロダクトに関わらないようにする
        * 組織的な要因などにより実現が難しい場合もある
    * 1つのチームでそのまま複数のプロダクトを管理する
        * 扱うすべてのプロダクトのPBIをひとつのプロダクトバックログにまとめる
        * プロダクトにまたがった優先順位付けが必要

> [!NOTE]
> 
> :memo:コメント
> 
> 大きいプロダクトだと大規模スクラムフレームワークの考え方を導入した方が話が早そう。（Katsuya）
>
> > プロダクトの構成要素
>
> 個人的にはユーザーに価値を与えている単位のアプリケーションがプロダクトと呼べる認識。MSの例なら、Officeという単位で購入してるかもしれないけれど価値を享受してるのはWordとかExcel
> という単位。（Katsuya）
>
> CODEの場合、単一チーム・複数プロダクトにあたるので、バックログは1つにまとめる、というのもありかも。ただし、それぞれの期間で見た場合、今のところは1つのプロダクトしか作っていないから、悩ましいところ。（RyoyaC）
>
