
# 第７章：トランザクション

### 本章の概要
* 本章では、トランザクションに関して問題となり得る例を説明し、そうした問題への対処するアルゴリズムを解説する
* 特に並行性の制御について掘り下げ、様々なレース条件と分離レベルについて説明する

### データシステムで生じる問題
* 書き込みの最中のソフトウェア・ハードウェア障害
* 操作途中のアプリケーションのクラッシュ
* ネットワーク断絶
* 複数クライアントの同時書き込みによる変更の上書き
* 部分的に更新されたデータ
* レース条件によるバグ

### トランザクション
* これらの問題を単純化する仕組み
* アプリケーションによる複数の読み書きを論理的にまとめる方法
    * トランザクション全体として成功（commit）または失敗（rollback/abort）しかない
    * トランザクションが失敗した場合はアプリケーションはリトライ可能
    * トランザクションはあらゆるアプリケーションで必要なわけではなく、トランザクションの保証を弱くしたり、トランザクションの保証を一切しないことでパフォーマンス改善もできる


## トランザクションというとらえどころのない概念

### 背景
* リレーショナルデータベースは、1975年のIBMのSystemRに由来し、トランザクション処理の基本を確立した
* 2000年代後半には、NoSQLデータベースの台頭があり、新しいデータモデルの選択肢を提供し、トランザクションを犠牲にする傾向が出てきた

### ACID
トランザクションが提供する安全性の保証
* 原子性(Atomicity)
* 一貫性(Consistency)
* 分離性(Isolation)
* 永続性(Durability)

#### BASE
* ACIDを満たさないシステム
* 要素
    * 基本的に利用可能(Basically Available)
    * 厳密ではない状態遷移(Soft State)
    * 結果整合性(Eventual consistency)
* ACIDの定義より曖昧で「ACIDではない」ことが妥当

#### 原子性
* クライアントが論理的にグループ化された複数の書き込みを実行中にエラーが発生したとき、グループ化された書き込み全体に対して成功（コミット）か失敗（ロールバック）しかないこと
    * トランザクションが失敗した場合は、その時点までに行われた書き込みは取り消される
    * 原子性がない場合、トランザクションの途中でエラーが生じた場合のエラーハンドリングが複雑になる
        * リトライすれば同じ変更を２回行うリスクがある
* 中断可能性（abortability）の方が原子性よりも適切な言葉だが、通常利用されている原子性という言葉を使用する

#### 一貫性
* 「一貫性」という言葉の多義性
    * リードレプリカの一貫性（結果整合性の問題）
    * コンシステントハッシュ法
    * CAP定理における一貫性は線形化可能性という意味で使われる
* ACIDにおける一貫性
    * データについて常に真でなければならないなんらかの言明（不変性）があること
        * 例）会計システムの場合、すべての科目の合計において貸方と借方は等しくなる
* 一貫性はアプリケーションの責務
    * このような不変性はアプリケーション固有のものなので、一貫性を保つようにトランザクションを定義するのはアプリケーションの責務
    * ACIDのうち、Cだけデータベースの責任ではない

#### 分離性
* レコードへの同時アクセス
    * 複数のクライアントが同時に同じレコードにアクセスすることがある
    * このときに並行性の問題（レース条件）が生じる可能性がある
* 直列化可能性(Serializability)としての意味
    * トランザクションが、データベース全体の中で実行されている唯一のトランザクションであるかのうように振る舞う
    * 並行に実行されても、それぞれが順番に実行されていた場合と同じ結果になることを保証する
* 現実
    * パフォーマンス上のペナルティが大きいため、直列化可能な分離性が用いられることはほとんどない
    * 実際にはスナップショット分離などの直列化可能性よりも弱い分離性を用いる

#### 永続性
* トランザクションのデータが失われないことを保証する
    * ハードウェア障害やデータベースクラッシュがあってもデータが失われないことを保証する
    * データの不揮発性ストレージへの書き込みや、レプリケーションの完了を待つことで実現される
* 絶対的な保証はない
    * すべてのハードディスクとバックアップが同時に破壊された場合、データベースにできることは何もない
    * リスクを低減する複数の手法を併用してリスクを可能な限り下げる

### 単一オブジェクトと複数オブジェクトの操作

#### 原子性と分離性の重要性
* 原子性（ACIDの一部）
    * トランザクション中のエラー時に中断し、途中までの書き込みを破棄する
    * ユーザーに部分的な障害を気にさせず、オールオアナッシングを提供
* 分離性（ACIDの一部）
    * 並行トランザクションが互いに影響しないように保証
    * 書き込みの一部だけが見えたり、すべてが見えたりすることを防止

#### マルチオブジェクトトランザクション
* これらの定義では、ユーザーが複数のオブジェクト（行、ドキュメント、レコード）を同時に更新するとみなす
* RDBでは`BEGIN TRANSACTION`から`COMMIT`の間に行われたすべての操作を同じトランザクションとみなす
    * 例
        * メールの個別の未読フラグと全体の未読数

#### 単一オブジェクトへの書き込み
* データベースが単一ノードにおける単一オブジェクト（キー・バリューペア）の原子性と分離性を提供する
    * 原子性はクラッシュリカバリ用のログで実装
    * 分離性はそれぞれのオブジェクトでのロックで実装
* 利点
    * 単一オブジェクトの操作は複数クライアントが並行に同じオブジェクトへの書き込みを行おうとした場合に更新が失われることを防ぐ

#### 複数オブジェクトトランザクションの必要性
* 多くの分散データストアは複数オブジェクトのトランザクションを放棄している
    * パーティションをまたいで実装することが難しい
    * 極めて高い可用性やパフォーマンスが求められる状況で難題になる
    * とはいえ、分散データベースでトランザクションが不可能なわけではない
        * 分散トランザクションについては第9章で扱う
* 複数オブジェクトトランザクションの必要性
    * RDBにおける外部キー参照の整合性を保つ
    * ドキュメントデータモデルで非正規化されたデータを更新する場合、一度に複数のドキュメントを更新する必要があり、それらの整合性を保つ
    * セカンダリインデックスを持つデータベースで、値を変更するたびにインデックスも更新する
        * トランザクションがなければ、値だけ変更され、インデックスは更新されていない状況に陥る可能性がある

#### エラーと中断の処理
* トランザクションの重要な機能はエラーが生じた際に中断でき、リトライできること
    * エラーが起こることは避けられないが、多くのソフトウェア開発者は複雑なエラー処理よりもうまくいく実行経路を考えたがる
* リトライ戦略の検討
    * アプリケーションレベルの重複排除
        * トランザクションが実際には成功しているにもかかわらず、結果送信時にネットワーク障害が起こればクライアントはトランザクションが失敗したとみなす
        * リトライを実行するとトランザクションは２回実行されることになる
    * 過負荷対処のための指数的バックオフ
        * 過負荷によってエラーが生じている場合、リトライを行うと問題は悪化する
        * この問題を避けるため、リトライ回数を制限し、指数的バックオフを用いて過負荷に対処する
    * 恒久的なエラーの場合はリトライしない
        * リトライすべきなのは、デッドロック、ネットワーク瞬断、フェイルオーバーなどの一時的なエラーの場合だけ
        * 恒久的なエラー（制約違反など）の場合はリトライしない
    * 2相コミット
        * トランザクションがデータベース外に副作用がある場合、トランザクションを中断しても副作用は残っている可能性がある
        * 複数のシステムをまとめてコミットもしくは中断される場合は2相コミットが役立つ



> [!NOTE]
> 
> :memo: 7.1節のコメント
>
> >ACIDの一貫性はアプリケーションの責務
>
> DDDにおけるエンティティや値エンティティ、集約といったパターンは、不変条件を強制することを前提としたパターンであり、業務システムのようなデータの一貫性が重要な分野でこのようなパターンが現れたのは、ある意味自然なのかなと思った(RyoyaC)

---

## 弱い分離レベル
* レース条件の問題
    * 並行トランザクションが同じデータにアクセスしない場合は、依存関係がなく安全
    * レース条件は、1つのトランザクションが他のトランザクションから並行して変更されるデータを読み取る、または2つのトランザクションが同時に同じデータを変更しようとする場合に問題
    * 並行性のバグはタイミングが悪い場合にのみ発生し、テストで見つけることが難しい
    * 大規模なアプリケーションでは、並行性を把握することが難しく、データベースが提供する分離性に頼る
* 分離レベル
    * 分離性は直列化可能性を保証し、開発者は並列処理が行われていないように見える
    * 分離性は単純ではなく、パフォーマンス上の負担もあるため、弱いレベルの分離性を提供するのが一般的
        * 弱いトランザクションの分離による並行性のバグは現実的な問題であり、損失や監査の必要性が生じることもある
    * ACIDデータベースでも弱い分離性が使われることがあり、開発者は並行性の問題を理解する必要がある

### Read Committed
* データベースにおけるもっとも基本的なレベルのトランザクションの分離性
* 以下2つを保証する
    * ダーティリードが生じないこと
    * ダーティライトが生じないこと

#### ダーティリードが生じないこと
* ダーティリードは他のトランザクションがコミットされていないデータを読むことであり、混乱を招く可能性がある
* あるトランザクションの書き込みが他のトランザクションからみえるようになるのはコミット後

#### ダーティライトが生じないこと
* ダーティライトは他のトランザクションが未コミットのデータを上書きすることであり、不整合を引き起こす可能性がある
* read committed分離レベルでは、ダーティリードを発生させないように未コミットのデータを上書きしようとしているトランザクションがある場合、コミットされるか中断されるまで遅らせられる

#### 実装
* read committedは一般的に使用される分離レベル
* ダーティライトを避ける方法
    * ロック（特に行レベルロック）
        * トランザクションがあるオブジェクト（行またはドキュメント）を更新する場合、そのオブジェクトのロックを取得する必要がある
        * そのロックはトランザクションが終了するまで保持される
        * あるオブジェクトのロックを取得できるのは1つのトランザクションのみ
* ダーティリードを避ける方法
    * ロック
        * 読み込むときにロックし、読み取り終了後ロックを解放する
        * 長時間にわたる書き込みトランザクションがあると多くの読み取りのみのトランザクションがその書き込みトランザクションが終了するまで待たなければならなくなる
        * 運用上レスポンスタイムが悪化するのは望ましくないため、ほとんどのDBでは採用していない
    * 別のアプローチ
        * コミット済みの古い値と書き込みロックを取得しているトランザクションが設定した新しい値を両方記憶しておく
        * トランザクション進行中は読み取りトランザクションには古い値が返却され、新しい値がコミットされた後、他のトランザクションから新しい値が読み取れるようになる


### スナップショット分離とリピータブルリード

#### スナップショット分離
* 読み取りスキュー（ノンリピータブルリード）
    * 例）
        * 保有する2つのアカウントのうち、片方から他方に送金するケース
        * このとき銀行口座の残高が不整合になる可能性がある
        * トランザクション処理中に残高のリストを読み取ると、不正確な残高が表示されることがある
    * これはread committed分離では許容される問題で、nonrepeatable readまたは読み取りスキューと呼ばれる
    * この問題が許容されないケース
        * バックアップ
            * バックアップには数時間以上かかることもあり、バックアップ処理中もデータベースへの書き込みは行われる
            * 読み取りスキューを許容していると、バックアップの一部は古いバージョンで、その他は新しいバージョンのデータとなる可能性がある
            * このバックアップからリストアすれば、不整合は恒久的になる
        * 分析的クエリ
            * データベース全体をスキャンして集計などを行うケースで、データベースの読み取る際の時刻がオブジェクトごとに異なっていると意味のない結果が返される可能性がある
* スナップショット分離
    * スナップショット分離はバックアップや分析的なクエリなど、長時間実行される読み取りだけのクエリに適している
    * 「一貫性のあるスナップショットから読み取りを行う」というアイデア
    * トランザクションが開始時点のデータベースの一貫したスナップショットを見ることができる
    * 主にPostgreSQL、MySQLのInnoDB、Oracle、SQLServerなどでサポートされている
#### 実装
* ダーティライトを防ぐ方法
    * read committed同様ロックを使用
* ダーティリードを防ぐ方法
    * MVCC（マルチバージョン並行性制御）
        * スナップショット分離の実装ではMVCCが一般的に使用される
        * トランザクションIDが割り当てられ、書き込まれたデータにはライターのトランザクションIDがタグ付けされる
        * 通常のアプローチでは、read committedではクエリごとに個別のスナップショットを使い、スナップショット分離ではトランザクション全体にわたって同じスナップショットを使う
        * 読み取りが書き込みをブロックすることはなく、書き込みが読み取りをブロックすることもない
        * データベースでは通常通り書き込み処理をしながら同時に実行される読み取りクエリをロックの競合を発生させることなく処理できる

--- 以下生成AIを利用
#### 一貫したスナップショットを見るための可視化ルール
* 行の管理
    * テーブル内の各行にはcreated_byフィールドがあり、行を挿入したトランザクションのIDを保持
    * deleted_byフィールドは削除された行を示すため、行が削除されるとこのフィールドに削除トランザクションのIDが設定される
* スナップショットの可視化ルール
    * トランザクションがデータベースから読み取る際、そのトランザクションのIDに基づいて行の可視性が決定される
    * データベースは一貫性のあるスナップショットを提供するため、可視化ルールを厳密に定義
    * ルールはトランザクションの開始時点における他のトランザクションのリストと、それらのトランザクションが行った書き込みを考慮

#### インデックスとスナップショット分離
* インデックスとスナップショット分離
    * MVCCを使用した場合、インデックスの動作が変化
    * インデックスはトランザクションの可視性を考慮して行のバージョンを指す
    * ガベージコレクションにより古いバージョンが削除されると、対応するインデックスのエントリも削除
* リピータブルリードと名前の混乱
    * スナップショット分離はリピータブルリードとしても知られている
    * SQL標準にはスナップショット分離の概念がなく、リピータブルリードが似た概念
    * しかし、リピータブルリードの定義は曖昧で、実装によって異なる

### 更新のロストの回避
* 概要
    * readcommitted と スナップショット分離レベル は読み取りのみのトランザクションと並行して書き込みが行われている場合の可視性を保証する
    * 2つの並行する書き込みトランザクション間で生じる 更新のロスト が重要
* 更新のロストの原因
    * read-modify-writeサイクル
        * 2つのトランザクションが同時にデータを読み取り、変更し、書き戻す
        * 2つ目の書き込みが1つ目の変更を無視し、変更が失われる可能性がある
* 典型的なシナリオ
    * カウンタや残高の更新、JSONドキュメントの一部の変更、同じページの同時編集など
#### アトミックな書き込み操作
* データベースが提供するアトミックな更新処理を利用
* ロックを取得してオブジェクトの読み取りと更新を一貫して実行する方法
#### 明示的なロック
* アプリケーションが更新対象のオブジェクトを明示的にロックする
* 他のトランザクションが読み取り待ちになり、更新が完了するまで待機する
#### 更新のロストの自動検出
* 並行する書き込みの検出とトランザクションの中断・リトライ
* スナップショット分離と組み合わせてデータベースが効率的にチェック
#### 衝突の解決とレプリケーション
* 概要
    * レプリケーションされているデータベースでは、更新のロストの回避には新たな手順が必要
    * 複数ノード上のコピーによって衝突が生じる可能性があるため、衝突の解決が重要
* 解決策
    * アプリケーションのコードまたは特別なデータ構造による衝突解決やマージ
        * マルチリーダーやリーダーレスレプリケーションでは衝突があり、それらを解決するためにアプリケーションのコードや特別なデータ構造が必要
        * レプリケーションが行われる環境でもアトミックな操作が機能し、Riakなど特定のデータベースでは自動的なマージが行われる
    * LWW（Last Write Wins）の制約
        * 一部のデータベースではLWWが衝突解決のデフォルトとなっており、更新のロストが生じる可能性がある

### 書き込みスキューとファントム
#### 書き込みスキュー
* 書き込みスキューの概要
    * 書き込みスキューは、同時に複数のトランザクションが同じオブジェクトに書き込みを行う場合に生じるレース条件の一つである
    * ダーティライトやダーティリードとは異なり、特定のオブジェクトの更新ロストではなく、複数のオブジェクトの読み書きに関わる
* 例
    * 例えば、病院の当直医の管理アプリケーションで、2人の医師が同時に帰宅希望を出す場合が挙げられる
    * 両者が同時に帰宅希望を選択し、更新処理を行うと、最低1人の医師が当直になっていない状態になり、要求が満たされなくなる
#### ファントムリード
* ファントムの概要
    * ファントムは、トランザクションの実行間に発生する不整合性であり、特定の条件を満たす行が存在しないことをチェックし、その後に行われる書き込みによって条件が変化する
* ファントムの例
    * 例えば、会議室予約システムで、同じ会議室に2つの予約が入ることを防ぐ場合が挙げられる
    * 2つの予約を同時にチェックし、重なる予約がなければ予約を作成するが、スナップショット分離レベルでは不十分であり、直列化可能分離レベルが必要である


#### 衝突の実体化
* 衝突の実体化は、ファントム問題を解決する一つの方法であり、ロックオブジェクトを導入してトランザクションを制御する手法である
* しかし、実装が複雑であり、データモデルに並行性の制御を漏らすことがあり、最後の手段として考えるべきである


> [!NOTE]
> 
> :memo:コメント
> 
> > レース条件
> レース条件はタイミングの問題なので、自動テストとして実装するとフレーキーテストになりそう。
また、そもそも特定の処理を並列で実行しないと起きないから、観点として漏れていると全く気づけず、対応もできない。(RyoyaC)

---

## 直列化可能性
* 最も強い分離レベル
* 本章では、トランザクションの並列化に弱い条件であるレース条件についていくつかの例を示します
* これらの条件はread committedやスナップショット分離レベルで回避できるものもありますが、できないものもあります
* 特に複雑な例には書き込みスキューやファントムが含まれます
* しかし、分離レベルの理解が難しく、アプリケーションのコードから特定の分離レベルでの安全性を判断することは困難です
* そのため、レース条件の検出を支援する優れたツールはまだ存在しません
### 完全な順次実行
* トランザクションの並列性を完全に排除し、1つのスレッドで順次処理する
* 最もシンプルな方法だが、実用的な性能を得るためにはデータベースの設計が必要
* トランザクションを順次実行するシステム（例：VoltDB、Redis、Datomic）がある
* 単一スレッドでの実行はロックのオーバーヘッドを避けられるが、スループットは1つのCPUコアのスループットに制限される
#### ストアドプロシージャへのトランザクションのカプセル化
* トランザクションをストアドプロシージャとしてデータベースに登録し、外部とのやり取りを含むトランザクションを禁止する
* トランザクションがメモリ中のデータのみを必要とする場合、ストアドプロシージャは高速に実行できる
#### ストアドプロシージャの長所と短所
* 長所
    * SQL標準の一部であり、データベース上での効率的な処理を可能にする
    * 現代的なプログラミング言語を使用した実装により、性能やメンテナンス性が向上している
    * インメモリデータと組み合わせることで、単一スレッドでのトランザクション実行が実現可能
* 短所
    * 各データベースベンダーが独自の言語を使用しており、時代遅れでエコシステムが不足している
    * デバッグ、バージョン管理、デプロイ、テスト、モニタリングがアプリケーションサーバーと比較して難しい
    * データベース内の効率的でないストアドプロシージャは重大なパフォーマンス問題を引き起こす可能性がある
#### パーティショニング
* パーティショニングの利点
    * 複数のCPUコアとノードにスケーリング可能
    * 各パーティションに専用のトランザクション処理を割り当て、並行動作を実現
    * トランザクションのスループットはCPUコア数に比例してスケーリング
* 課題
    * パーティション間でのトランザクションは調整が必要であり、速度が低下する可能性がある
    * 複雑なデータ構造や複数のセカンダリインデックスを持つ場合、調整のオーバーヘッドが大きくなる
### ツーフェーズロック
* 概要
    * 直列化可能分離レベルを実現するために、長い間使われてきたアルゴリズムの1つ
    * ツーフェーズロック（2PL）はトランザクションの実行中と終了時にロックを取得・解放する方式
* ツーフェーズロックと2PCの違い
    * 2PC（2相コミット）とは別物
    * ツーフェーズロックは直列化可能性を提供する
#### 実装
* MySQL（InnoDB）、SQLServer、DB2などで使用
* リーダーとライターがオブジェクトごとにロックを取得し、共有モードまたは排他モードで保持
* ロックの要求や解放に基づいてトランザクションが実行を制御
#### パフォーマンス
* 長期間の利用はパフォーマンスの問題があった
* 多数のロック取得や解放のオーバーヘッドがあり、並行性の低下も問題

#### 述語ロック
* ファントム問題の解決に必要
* 特定の条件にマッチするオブジェクト全体にロックを適用
* ロックの要求や解放によってトランザクションの処理を制御
#### インデックス範囲ロック
* 問題点
    * 述語ロックのパフォーマンスは低い。アクティブなトランザクションが多くのロックを取ると、マッチするロックを調べるのに時間がかかる
* 解決策
    * インデックス範囲ロック（next-keyロック）を使用。これは述語ロックを単純化したもので、安全かつ効率的
* 具体例
    * 123号室の正午から午後1時までの予約を探す場合、123号室をすべての時間に対してロックしたり、正午から午後1時までのすべての部屋をロックする
* 実装方法
    * データベースがroom_idやstart_time、end_timeなどの列にインデックスを張る。インデックスを使用して予約を検索し、適切なロックを適用する

### 直列化可能なスナップショット分離
* 問題
    * 直列化可能性と優れたパフォーマンスの両立は難しい
* 解決策
    * 直列化可能スナップショット分離（SSI）アルゴリズムを使用。完全な直列化可能性を提供しつつ、パフォーマンスに優れる
* 特徴
    * SSIは直列化可能性とスナップショット分離を組み合わせ、大きな期待が持てる新しいアルゴリズム
* 実装例
    * PostgreSQLの直列化可能分離レベルやFoundationDBなどで使用されている

#### 悲観的な平行性制御と楽観的な平行性制御
* 悲観的な制御
    * ツーフェーズロックは悲観的な制御で、安全を優先し、競合が起きないようにロックを使用
* 楽観的な制御
    * 直列化可能スナップショット分離は楽観的な制御で、問題が起きないと期待し、トランザクションを中断することなく進行
* パフォーマンス
    * 楽観的な制御は競合が少ない場合には悲観的な制御よりも優れたパフォーマンスを発揮する
* SSIの特徴
    * SSIはスナップショット分離と直列化可能性を組み合わせたアルゴリズムで、楽観的な制御を採用している

#### 古くなったプレミスに基づく判断
* 問題点
    * スナップショット分離レベル下では、トランザクションのコミットまでにデータが変更され、元のクエリ結果が最新でない可能性がある
* 原因
    * プレミス（トランザクション開始時点での真の事実）に基づいてアクションを起こそうとするが、後にプレミスが変化する可能性がある
* 対策
    * データベースはトランザクションの古くなったプレミスに基づく処理を検出し、必要に応じてトランザクションを中断する

#### 古くなったMVCCの読み取りの検出
* 実装
    * スナップショット分離レベルでは、MVCC（マルチバージョン並行性制御）によって実装される
* 検出方法
    1. トランザクションが古いバージョンのMVCCオブジェクトを読み取る
    2. 読み取り後に他のトランザクションがそのデータを変更する

#### 先行する読み取りに影響する書き込みの検出
* 検出方法
    * 他のトランザクションが先行する読み取りに影響する書き込みを検出する
* 実装手法
    * トランザクションがデータを読み取った後、そのデータに影響を与える可能性のある書き込みを確認
    * 書き込みがコミットされる前にトランザクションを中断する必要がある場合がある

#### 直列化可能スナップショット分離のパフォーマンス
* エンジニアリングの細部の影響
    * アルゴリズムの効果はエンジニアリングの詳細によって大きく影響される
    * トランザクションの読み書きを追跡する粒度のトレードオフがある
* 他のトランザクションの影響
    * 他のトランザクションが上書きした情報を読んでも問題がない場合がある
    * PostgreSQLは不要な中断を減らすためにこの理論を利用している
* 直列化可能スナップショット分離の利点
    * ブロックされないトランザクションの待ちが少ない
    * クエリのレイテンシが予測可能で変動が少ない
    * 読み取り専用クエリはロックを必要とせず、一貫したスナップショット上で実行できる
* スループットの拡張性
    * 直列化可能スナップショット分離は単一のCPUコアに限定されない
    * FoundationDBは複数マシンに分散して直列化の競合を検出し、高いスループットにスケーリングできる
* データのパーティショニング
    * 複数のマシンにまたがるデータでも直列化可能分離レベルを保証したままトランザクションを実行できる
* 中断の比率とパフォーマンス
    * 中断の比率は全体的なパフォーマンスに影響する
    * 長期間のトランザクションは中断の可能性が高いため、SSIでは短いトランザクションが求められる
    * SSIは低速なトランザクションの影響を受けにくい

---
## まとめ


> [!NOTE]
> 
> :memo:全体へのコメント
> 
> トランザクションの分離レベルの整理
> 
> | 分離レベル | ダーティ<br>リード | インコンシステント<br>リード | ロスト<br>アップデート | ファントム<br>リード |
> | -------- | -------- | -------- | -------- | -------- |
> | read uncommitted     | 〇     | 〇     | 〇     | 〇     |
> | read committed     | ×     | 〇     | 〇     | 〇     |
> | repeatable read     | ×     | ×     | 〇     | 〇     |
> | serializable     | ×     | ×     | ×     | ×     |
> 
> ※ 引用：奥野幹也『理論から学ぶデータベース実践入門 リレーショナルモデルによる効率的なSQL』技術評論社. 2015.pp.340.
> 
> ※ 上記の〇は発生し得ることを示しており、×は発生しないことを示す
> 
> 用語の補足（「：」の右側が本章における用語）
> * インコンシステントリード：読み取りスキュー
> * ロストアップデート：更新のロスト
> * ファントムリード：ファントム
> * read uncommited：本章では定義されていない
> * repeatable read：スナップショット分離
> * serializable：直列化可能性
> 