# 第1章：信頼性、スケーラビリティ、メンテナンス性に優れたアプリケーション

## 本章の概要

本章では、データシステムで実現しようとしている信頼性、スケーラビリティ、メンテナンス性の基礎を明確にし、次章以降の基礎を整理する。

## アプリケーションの処理による分類

- 演算指向
  - CPUの処理能力が問題になる
- データ指向
  - データの量、複雑さ、変化速度が問題になる

:::success
:memo:コメント
> 演算指向

- ブロックチェーンとか？VRなども？

> 演算指向よりデータ指向

- たしかにデータ量に起因することばかりが問題になっていて、真にCPUスペックが必要な場面はほとんどないかも。

> 信頼性とスケーラビリティを持ちながらメンテナンスしやすいデータシステムを...

- MUSTで必要なのは先2つであり、それに追随する形でメンテナンスのしやすさを求めるイメージかな
- MUSTで必要なのは信頼性で、データの規模が大きい・大きくなると期待される場合にはスケーラビリティが重要で、それに加えてメンテナンス性が必要、というイメージかも？

:::

## 1.1：データシステムに関する考察


:::success
:memo:コメント
> データシステムという包括的な用語の下でまとめる

- RedisとかKafkaは使ってるけど位置付けとか曖昧かも。
:::

## 1.2：信頼性
- 信頼性＝「フォールトがあってもシステムが正しく動作できること」


:::spoiler 参考：ISTQBの欠陥、エラー、故障の定義
[ISTQBの定義](https://jstqb.jp/dl/JSTQB-SyllabusFoundation_Version2018V31.J03.pdf)だと、フォールト＝欠陥
- 欠陥:
- 故障:
- エラー:
:::

### システム障害の原因（≒フォールトの分類）
- ハードウェアの障害
- ソフトウェアのエラー
- ヒューマンエラー

### 信頼性を高める方法
* エラーの発生を抑止する
    * うまく設計された抽象化、API、インターフェースで間違いにくくする
* 間違いやすい部分を分離する
    * サンドボックス環境と本番環境を分離して、本番データをサンドボックス環境に持ち込みテストする
* 徹底的なテスト
    * 自動テストを活用し、UT、IT、STなど包括的にテストする
* 迅速なリカバリ
    * 障害が発生してもその影響を最小化できるようにすぐ復旧できるようにする
* メトリクスの取得
    * メトリクスを見ることで警告シグナルを早期発見でき、チェックできる
* 優れた管理方法とトレーニングの実践
    * 本書の範囲外

:::success

:memo:コメント 

> フォールトが障害を引き起こ...

- フォールトはコンポーネントの状態、それによって障害が起きる場合がある

> ソフトウェアが動作環境に関して何らかの前提を置いている

- これを明示するの大事かも。暗黙の了解をなくし、前提を明示して、障害発生時には置いた前提から逸れていることを認識できるように。

> うまく設計された抽象化、API、インターフェースで間違いにくくする
- DDDのしなやかな設計とかもこういうニュアンス出してた気がする
:::

## 1.3：スケーラビリティ
- スケーラビリティ＝「負荷の増大に対してシステムが対応できる能力」(p.11)
### 負荷の表現
* 負荷のパラメータの数値で表現する
* 最適なパラメータはシステムによって異なる
    * Webサーバ：リクエスト数/秒
    * データベース：読み書き比率
    * チャットルーム：同時アクティブユーザー数
    * キャッシュ：ヒット率
### パフォーマンスの表現
* 負荷、リソース、パフォーマンスの関係性
    * 負荷パラメータを増やし、システムリソースは一定の場合システムのパフォーマンスにどう影響するか
    * 負荷パラメータを増やし、システムのパフォーマンスを一定に保つにはシステムリソースをどれほど増やす必要があるか
#### 分布による計測の必要性
* 同じリクエストを繰り返ししても各リクエストごとにレスポンスタイムは異なる
* 全体のリクエストのうち、50パーセンタイル、95パーセンタイル、99パーセンタイルのメトリクスを分析することで、「典型的な」レスポンスタイムがわかる
    * 統計の基礎を心得ていると当たり前なんだけど、バシッと特定の数値を扱えるわけではないという理解はプロジェクト全体で持っていたい
* テイルレイテンシ
    * 大きなパーセンタイルのレスポンス値
    * 特に処理に時間がかかっているリクエストをしているユーザーは、大量の購入をして自分のアカウントに大量のデータを持っているユーザーで、重要顧客であることが多い
* パーセンタイル値でメトリクスを効率的に計算するアルゴリズム
    * forward decay
    * t-digest
    * HdrHistogram
### 負荷への対処のアプローチ
* スケーリングの種類
    * 垂直スケーリング（=スケールアップ: マシンスペックを上げる）
    * 水平スケーリング（=スケールアウト: 複数マシンに分散させる）
        * = shared-nothingアーキテクチャ
* スケーリングの方法はアプリケーション固有の事情による
    * 負荷の予測が難しい場合はオートスケーリングが役立つ
    * 複雑で、運用時に想定外の事象が発生する可能性がある
    * ステートフルなサービス（DBなど）のスケーリングは難しい
> - 「初期の段階にあるスタートアップや、まだ検証されていないプロダクトの場合、通常は仮説に基づく将来の負荷に応じてスケールすることよりも、プロダクトの機能に関するイテレーションを素早く行えることの方が重要」（p.19）

## 1.4：メンテナンス性

- メンテナンス性が重要である背景
  - ソフトウェアのコストは初期の開発コストだけでなく運用中のメンテナンスコストも発生する
    - バグ修正
    - 障害調査
    - 新プラットフォームへの対応
    - 新しいユースケースへの対応
    - 技術的負債の返済
    - 機能追加
  - レガシーシステムのメンテナンスは難しい
  - 苦痛を最小化し、レガシーシステムを生み出すのをさけるために設計する
- 特に注意すべき設計原理
  - 運用性
    - 運用チームが扱いやすいようにする
    - どういうものが扱いやすいのか？
  - 単純性
    - 新しいエンジニアが理解しやすいようにする
    - 複雑性を取り除く
    - （UIの単純性とは異なる観点）
  - 進化性
    - 要求の変化による想定外のユースケースへの対応をしやすいようにする
    - 拡張性、修正容易性、プラスティシティとも呼ぶ
- 運用性：運用担当者への配慮
  - 運用チームの責任（の一部）
    - システムの健全性のモニタリング、状態が悪い場合は素早くサービスの回復
    - 障害やパフォーマンス低下の原因調査
    - プラットフォームの最新化、セキュリティパッチの適用
    - システムの相互作用に注目し、問題の事前回避
    - プラットフォーム移行、複雑なメンテナンスタスクの実行
    - プロダクション環境を安定させるため、想定外のことが起こらないプロセスを定義する
    - プロジェクトへの人の出入りにより組織の知識を保てるように俗人化の防止
  - 優れた運用性は定型タスクを容易にする
  - 以下のことが定型タスクを容易にする
    - ランタイムの挙動、システム内部のモニタリング
    - 自動化と標準的なツールとの結合
    - 個々のマシンへの依存性を持たせない
    - 優れたドキュメンテーション
    - デフォルトの挙動を優れたものにする
    - 適切な場合には自己回復できるようにする
    - 挙動を予測しやすいようにして、予想外のことができる限り起きないようにする
- 単純性：複雑さの管理
  - 複雑さの問題
    - 小さなプロジェクトではシンプルなコードであっても、プロジェクトの成長とともにコードが複雑で理解しにくくなる
      - 複雑さから生じる症状
          - 状態空間の爆発
          - モジュール間の密結合
          - 依存関係のもつれ
          - 一貫性のない命名
          - パフォーマンス問題を解決するためのハック
          - どこかの問題を解決するための特別な対応
    - 複雑さでメンテナンス性が下がると予算とスケジュールが膨れ上がり、変更時のリスクが大きくなる
  - システムを単純にすることの意味
    - システムを単純にする≠機能を減らす
    - システムを単純にする＝偶発的な複雑さを取り除く
      - 偶発的な複雑さ＝「ソフトウェアが解決しようとしている（ユーザーから見た）問題がもともとは持っておらず、実装からのみ生じている複雑さ」
  - 偶発的複雑さを取り除く手段
    - 抽象化
- 進化性：変更への配慮
  - システムへの要求は常に変化する
    - ビジネス優先順位の変更
    - 新機能の要望
    - プラットフォームの移行
    - 法的規制への順守による変更
    - 成長に伴うアーキテクチャ刷新
  - アジリティ
    - 複数のアプリケーションやサービスから構成される大規模なレベルのデータシステムで、頻繁な変化に対応する
    - システムの修正は、単純さと抽象化に密接に関係する
      - 単純で理解しやすいシステムは複雑なシステムに比べて修正しやすい
      - データシステムレベルのアジリティのことを進化性という別の名前で定義
