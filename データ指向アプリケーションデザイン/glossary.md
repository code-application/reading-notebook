# 用語集

### 2相コミット（2PC）（two-phase commit）
複数のデータベースノードでトランザクションがすべてコミットするか、もしくはすべて中断となることを保証するアルゴリズム。「9.4.1 アトミックなコミットと2相コミット（2PC）」参照。

### CAP定理（CAP theorem）
広く誤解されている理論的な成果で、実際的には有益ではない。「9.2.4.1 CAP定理」参照。

### ETL
抽出（Extract）、変換（Transform）、ロード（Load）。データをソースデータベースから抽出し、分析的なクエリにより適した形態に変換し、データウェアハウスあるいはバッチ処理してシステムへロードするプロセスのこと。「3.2.1 データウェアハウス」参照。

### OLAP（Online analytic processing）
オンライン分析処理。大量のレコードに対する集計（たとえばカウント、合計、平均）がアクセスパターンの特徴。「3.2 トランザクション処理か、分析処理か？」参照。

### OLTP（Online transaction processing）
オンライントランザクション処理。通常はキーによってインデックス付けされた少量のレコードの読み書きを高速に行うことがアクセスパターンの特徴。「3.2 トランザクション処理か、分析処理か？」参照。

### アトミック（atmic）
1. 並行処理の文脈においては、ある時刻上の一点で有効になる操作で、他の並行プロセスからは「半分完了した」状態に見えることがない処理を言う。分離性（isolation）も参照。
2. トランザクションの文脈においては、仮に障害が起きたとしてもすべてがコミットもしくはロールバックされなければならない一群の書き込みをグループ化すること。「7.1.1.1 原子性」及び「9.4.1 アトミックなコミットと2相コミット（2PC）」参照。

### 因果関係（causality）
イベント間の依存関係で、システム中であるイベントが他のイベントよりも「前に生じた」際に生じるもの。たとえば、後に生じるイベントで、先行するイベントへのレスポンスであったり、先行するイベントに基づいたもの、あるいは先行するイベントに照らして理解すべき後方のイベント。「5.4.4.2 「事前発生（happens-before）」関係と並行性」及び「9.3.1 順序と因果関係」参照。

### インデックス（index）
特定のフィールドに特定の値を持つすべてのレコードを効率的に検索できるようにしてくれるデータ構造。「3.1 データベースを駆動するデータ構造」参照。

### キャッシュ（cache）
最近使われたデータを記憶し、同じデータの将来の読み取りを高速化するコンポーネント。これは一般に完全なデータではないので、キャッシュに欠けているデータがあれば、下位層のデータの完全なコピーを持つ低速なデータストレージシステムから取得しなければならない。

### 記録のシステム（system of record）
データの主たる信頼できるバージョンを保持するシステム。真実のソースとも呼ばれる。変更はまず個々に書き込まれ、他のデータセットは記録のシステムから導出されることがある。第Ⅲ部の導入部参照。

### クオラム（quorum）
操作が成功したと見なされるために、投票する必要があるノードの最小数（通常、全体のノードの過半数）。「5.4.1.2 読み書きのためのクオラム（Quorum）」参照。

### グラフ（graph）
頂点（参照できるもの。ノードあるいはエンティティと呼ばれることもある）と辺（1つの頂点から他の頂点への接続。関係性あるいは弧と呼ばれることもある）からなるデータ構造。「2.3 グラフ型のデータモデル」参照。

### 決定的（deterministic）
同じ入力が与えられれば常に同じ出力を生成する関数のこと。これは、その関数が乱数や、時刻、ネットワークの通信、あるいはその他の予測できないことに依存できないことを意味する。

### 合意（consensus）
分散コンピューティングにおける根本的な問題で、何かについて複数のノードの同意を取ること（たとえばデータベースクラスタのリーダーにどのノードがなるべきか）。この問題は、最初の印象よりもはるかに難しい問題である。「9.4.3 耐障害性を持つ合意」参照。

### シェアードナッシング（shared-nothing）
それぞれにCPU、メモリ、ディスクを持つ独立したノード群が従来のネットワークで接続されたアーキテクチャ。共有メモリや共有ディスクのアーキテクチャとは対照的。第Ⅱ部の導入部参照。

### スキーマ（schema）
データの構造の記述で、そのフィールドやデータ型が含まれる。データがスキーマに従っているかどうかは、そのデータの生存期間中の様々な時点でチェックでき（「2.1.5.2 ドキュメントモデルにおけるスキーマの柔軟性」参照）、スキーマは時間とともに変化しうる（4章参照）。

### スキュー（skew）
1. パーティション間での負荷の不均衡。たとえばいくつかのパーティションが大量のリクエストやデータを持ち、その他のパーティションははるかに少ない場合。ホットスポットとも呼ばれる。「6.2.3 ワークロードのスキューとホットスポットの軽減」及び「10.2.2.5 スキューの処理」参照。
2. イベントが予想外に、シーケンシャルではない順序で現れる原因となる、タイミングの異常。読み取りのスキューに関する議論は「7.2.2 スナップショット分離とリピータブルリード」を、書き込みのスキューについては「7.2.4 書き込みスキューとファントム」を、クロックのスキューについては「8.3.3.1 順序関係を持つイベントのタイムスタンプ」を参照。

### ストアドプロシージャ（stored procedure）
トランザクションのロジックを完全にデータベースサーバー上で実行し、トランザクションの間、クライアントとのやりとりを不要にするようなロジックのエンコーディング方法。「7.3.1 完全な順次実行」参照。

### ストリーム処理（stream process）
終わりのないイベントのストリームを入力として取り、そこから何らかの出力を導き出すような連続的な演算処理。11章参照。

### スプリットブレイン（split brain）
2つのノードが同時に自分がリーダーだと信じてしまい、そのためにシステムの保証が破られかねないような状態。「5.1.3 ノード障害への対処」及び「8.4.1 真実は多数決で決定される」参照。

### 正規化（normalized）
冗長性や重複がないように構造化されていること。正規化されたデータベースでは、データの一部が変更された場合、その変更が必要なのは一カ所だけであり、複数の様々な箇所で複数のコピーを変更する必要はない。「2.1.3 多対一と多対多の関係」参照。

### セカンダリインデックス（secondary index）
主なデータストレージとあわせてメンテナンスされる追加のデータ構造で、特定条件にマッチするレコードの効率的な検索を可能にする。「3.1.5 その他のインデックス構造」及び「6.3 パーティショニングとセカンダリインデックス」参照。

### 線形化可能性（linearizable）
システム中に、アトミックな操作によって更新される単一コピーのデータだけがあるように振る舞うこと。「9.2 線形化可能性」参照。

### 宣言的（declarative）
何かが持つべき属性を記述するが、それを得るための厳密な手順は記述しない。クエリの文脈においては、クエリオプティマイザは宣言的なクエリを受け取り、その最適実行方法を決定する。「2.2 データのためのクエリ言語」参照。

### 全順序（totalorder）
2つのもの（たとえばタイムスタンプ）の大小を常に判定できる比較の方法。比較できない（大小を判定できない）ものを含む順序づけは半順序と呼ばれる。「9.3.1.1 因果律に基づく順序と全順序の違い」参照。

### 全文検索（full-text search）
任意のキーワードによるテキストの検索。しばしば、スペルの似た単語や類義語のマッチといった追加機能を持つ。全文検索インデックスは、こういったクエリをサポートするセカンダリインデックス（secondary index）の一種である。セカンダリインデックス（secondary index）の項目と「3.1.5.3 全文検索と曖昧インデックス」参照。

### 耐久性（durable）
様々なフォールトがあったとしても、データが失われることがないと考えられるような方法でデータを保存すること。「7.1.1.4 永続性」参照。耐障害性（fault-tolerant）何か問題が生じても（たとえばマシンがクラッシュしたりネットワークのリンクに失敗したりしても）自動的に回復できること。「1.2 信頼性」参照。

### タイムアウト（timeout）
フォールトを検出する最も単純な方法の1つで、すなわち一定時間内にレスポンスがないことを観察する。しかし、タイムアウトが発生したのがリモートノードの問題によるのか、あるいはネットワークの問題によるのかを知ることはできない。「8.2.3 タイムアウトと限度のない遅延」参照。

### 直列化可能（serializable）
複数のトランザクションが並行に実行されたとき、それらがある順序に従って1つずつ実行されたのと同じように振る舞うことの保証。「7.3 直列化可能性」参照。

### ツーフェーズロック（2PC）（two-phase locking）
直列化可能な分離を実現するためのアルゴリズムで、トランザクションが読み書きするすべてのデータのロックを取り、そのロックをトランザクションの完了まで保持することによって動作する。「7.3.2 ツーフェーズ（2相）ロック（2PL）」参照。

### データウェアハウス（data warehouse）
複数の異なるOLTPシステムからのデータを組み合わせ、分析目的で利用できるようにしたデータベース。「3.2.1 データウェアハウス」参照。

### 同期（synchronous）
非同期（asynchronous）の反対。非同期（asynchronous）の項目を参照。

### 結合（join）
共通する何かを持つレコード同士をまとめること。最もよく使われるのは、あるレコードが他のレコードへの参照（外部キー、ドキュメント参照、グラフにおける辺）を持ち、クエリがその参照先のレコードを取得する必要がある場合。「2.1.3 多対一と多対多の関係」及び「10.2.2 Reduce側での結合とグループ化」参照。

### 導出データ（derived data）
再現可能な処理を通じて、他のデータから生成されるデータセット。この処理は、必要に応じて実行し直すことができる。通常、導出データは特定の種類の読み取りアクセスを高速化するために必要となる。インデックス、キャッシュ、マテリアライズドビューは導出データの例である。第Ⅲ部の導入部参照。

### トランザクション（transaction）
複数の読み書きを1つの論理的な単位にグループ化し、エラー処理や並行性の問題を単純化すること。7章参照。

### ノード（node）
コンピュータ上で何らかのソフトウェアが動作しているインスタンス。タスクを実行するために、他のノードとネットワークを通じて通信する。

### パーセンタイル（percentile）
ある閾値以上あるいは以下の値がいくつあるのかを数えることによって値の分布を計測する方法。たとえば、ある期間内の95パーセンタイルのレスポンスタイムは、その期間内のリクエストの95%がt以内に完了し、5%がt以上に時間がかかったような時間tである。「1.3.2 パフォーマンスの表現」参照。

### パーティショニング（partitioning）
単一のマシンで扱うには大きすぎる大規模なデータセットや演算処理を小さい部分に分割し、複数のマシンに分配すること。シャーディングとも呼ばれる。6章参照。

### バックプレッシャー（back pressure）
受信側が追従できないことから、データの送信元をスローダウンさせること。フロー制御（flow control）とも呼ばれる。フロー制御（flow control）の項目と「11.1.1 メッセージングシステム」参照。

### ハッシュ（hash）
入力をランダムに見える数値に変換する関数。同じ入力からは常に同じ数値が出力として返される。2つの異なる入力からは、2つの異なる数値が出力として返される可能性が極めて高いものの、2つの異なる入力が同じ出力を生成することはありえる（これは衝突と呼ばれる）。「6.2.2 キーのハッシュに基づくパーティショニング」参照。

### バッチ処理（batch process）
固定（そして通常は大きな）データセットを入力として受け取り、出力として他のデータを生成する演算処理。入力は変更しない。10章参照。

### ビザンチン障害（Byzantine fault）
何らかの恣意的な形でノードが不正に振る舞うこと。たとえば、矛盾していたり、悪意があるメッセージを他のノードに送信するなど。「8.4.2 ビザンチン障害」参照。

### 非正規化（denormalize）
ある程度の冗長性や重複を正規化されたデータセットに導入すること。典型的にはキャッシュあるいはインデックスの形で、読み取りの速度を上げるために行う。非正規化された値は、一種の事前に計算されたクエリの結果であり、マテリアライズドビューに似ている。「7.1.2 単一オブジェクトと複数オブジェクトの操作」及び「11.2.4.2 イベントログからの複数のビューの導出」参照。

### 非同期（asynchronous）
何かが（たとえばネットワークを通じた他のノードへのデータ送信が）終わるのを待たず、その処理にかかる時間についても前提を置かないこと。「5.1.1 同期と非同期のレプリケーション」、「8.2.4 同期ネットワークと非同期ネットワーク」、「8.4.3 システムモデルと現実」参照。

### フロー制御（flow control）
バックプレッシャー（backpressure）の項目を参照。

### フェイルオーバー（failover）
単一のリーダーを持つシステムの場合、フェイルオーバーはリーダーシップの役割をあるノードから他のノードへ移すプロセス。「5.1.3ノード障害への対処」参照。

### フォロワー（follower）
クライアントからの書き込みを直接は受け付けず、リーダーから受信したデータの変更だけを処理するレプリカ。セカンダリ、スレーブ、リードレプリカ、ホットスタンバイとも呼ばれる。「5.1リーダーとフォロワー」参照。

### プライマリキー（primary key）
レコードをユニークに特定する値（通常は数値もしくは文字列）。多くのアプリケーションでは、プライマリキーはレコードの生成時にシステムによって生成される（たとえばシーケンシャルに、あるいはランダムに）。通常プライマリキーはユーザーによっては設定されない。セカンダリインデックス（secondary index）の項目も参照のこと。

### 分散（distributed）
ネットワークによって接続された複数のノード上で動作すること。部分障害によって特徴付けられる。すなわち、システムの一部が壊れているかもしれないものの他の部分は依然として動作しており、しばしばソフトウェアにとっては正確に何が壊れているのかを知ることが不可能である。「8.1 フォールトと部分障害」参照。

### 分離性（isolation）
トランザクションの文脈において、並行に実行されているトランザクション同士が、お互いに干渉できる度合いを示す。直列化可能分離性は最も強い保証を提供するものの、もっと弱い分離レベルも使われる。「7.1.1.3 分離性」参照。

### 冪等（idempotent）
安全にリトライできる処理のこと。仮に2回以上実行されたとしても、1回だけ実行されたのと同じ効果しか及ぼさない。「11.3.4.3 冪等性」参照。

### マテリアライズ（実体化）（materialize）
演算を要求された時点で行うのではなく、事前に行ってその結果を書き出しておくこと。「3.3.4 集計：データキューブとマテリアライズドビュー」及び「10.3.1 中間的な状態の実体化」参照。

### 有限（bound）
上限や大きさが既知であること。たとえばネットワークの遅延（「8.2.3 タイムアウトと限度のない遅延」）やデータセット（11章の導入部参照）に関する文脈で使われる。

### 有限でない（unbound）
上限や大きさが既知でないこと。有限（bound）の反対。有限（bound）の項目も参照。

### リーダー（leader）
データあるいはサービスが複数のノードにわたってレプリケーションされる場合、変更を行うことが許されたレプリカがリーダーである。リーダーは何らかのプロトコルを通じて選出されるか、管理者によって手動で選択される。プライマリあるいはマスターと呼ばれることもある。「5.1 リーダーとフォロワー」参照。

### リバランス（rebalance）
負荷を公平に分散させるために、データあるいはサービスをあるノードから別のノードへ移動させること。「6.4 パーティションのリバランシング」参照。

### レプリケーション（replication）
あるノードが到達不可能になってもデータはアクセス可能でありつづけるよう、同じデータのコピーを複数のノード（レプリカ）に保持すること。5章参照。

### ローカリティ（locality）
パフォーマンス最適化の一種で、頻繁に同時に必要になる複数のデータ片を同じ場所に置くこと。「2.1.5.3 クエリのためのデータローカリティ」参照。

### ログ（log）
追記のみが行われる、データを保存するファイル。ライトアヘッドログは、クラッシュに対しての耐性をストレージエンジンに持たせるために利用され（「3.1.3.1 Bツリーの信頼性を高める」参照）、log-structuredストレージエンジンは主たるストレージフォーマットとしてログを利用し（「3.1.2 SSTableとLSMツリー」参照）、レプリケーションログはリーダーからフォロワーへ書き込みをコピーするために使われ（「5.1 リーダーとフォロワー」参照）、イベントログはデータストリームを表現できる（「11.1.2 パーティション化されたログ」参照）。

### ロック（lock）
単一のスレッド、ノード、トランザクションのみが何かにアクセスできることを保証する仕組み。同じものにアクセスしようとした他者は、ロックが解放されるまで待たされなければならない。「7.3.2 ツーフェーズ（2相）ロック（2PL）」及び「8.4.1.1 リーダーとロック」参照。

