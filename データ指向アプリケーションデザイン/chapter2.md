# 第2章：データモデルとクエリ言語

### 本章の概要
- 本章では、データの保存とクエリのためのデータモデルを解説する
- とくに、リレーショナルモデル、ドキュメントモデル、グラフモデルを比較する
- 様々なクエリ言語とそれらのユースケースも説明する
- ※ 次の第３章ではストレージエンジンの動作を取り上げて、データモデルがどのように実装されているのか説明する

### データモデルの重要性
- データモデルはソフトウェア開発で最も重要な部分
- 以下の2側面で影響するから
    1. ソフトウェアの書き方（コードのスタイル、アーキテクチャ）
    2. 解決しようとしている問題に対する考え方

- データモデルの種類によって、データ変換の容易さやパフォーマンスに影響が出る

> [!NOTE]
> :memo:コメント
>
> > 抽象化によって...効率的に共同で作業できる
>
> 裏を返せば、効率的になっていない場合は適切な抽象化になっていないという検査ができそう（Katsuya）

## 2.1：リレーショナルモデルとドキュメントモデル
### 最も有名なSQLのデータモデル
* リレーショナルデータモデルに基づく
* リレーショナル(=テーブル)としてデータを表現し、各リレーションは順序なしタプル(=行)の集合を表す
* 当時はデータ表現で多くのことを考慮する必要があり、リレーショナルモデルはクリーンなインターフェースで実装の詳細を隠蔽することを目標にした

### 代替データモデル
* オブジェクトデータベースが登場
    * ネットワークモデル
    * 階層モデル
* リレーショナルモデルが圧倒
* リレーショナルモデル以外の有力選択肢としてNoSQLが登場

### NoSQLが広がった要因
* 巨大なデータセットにおいて、高い書き込みスループットがあり、RDB以上のスケーラビリティが求められるようになった
* 商用DBよりもフリーかつオープンなDBが好まれるようになった
* RDBの制約による限界から新たな需要が生まれた
    * RDBでサポートされない特殊なクエリ操作
    * 柔軟なスキーマで表現力に富むデータモデル

### SQLデータモデルへの批判：オブジェクトとリレーションのミスマッチ
* インピーダンスミスマッチ
    * オブジェクト（OOPのオブジェクト）とテーブル、行、列への変換レイヤーが必要になってしまうこと
    * ActiveRecord, HibernateなどのORMが定型コードを減らすが、完全には隠蔽できない

### ネットワークモデル
* CODASYL(Conference on Data Systems Languages)モデル
    * 階層モデルを一般化したもの
    * 階層モデルの構造では、すべてのレコードは必ず1つだけ親を持つ
    * ネットワークモデルでは複数の親を持つこともできる
    * これによって多対一や多対多の関係をモデル化できる
* ネットワークモデルではレコード間のリンクは外部キーではなく、ルートのレコードからリンクの連鎖に沿って辿っていくだけ（=アクセスパス）
* 多対多の関係の場合、すべての関係を追跡する必要があり、データへのアクセスパスがわかっていない場合、プログラマがクエリを調べ、新しいアクセスパスを扱えるように書き変える必要があった
* このことから、アプリケーションのデータモデルを変更する際のコストが大きかった

### リレーショナルモデル
* 入り組んだ構造もなく、複雑なアクセスパスをたどらなくてもデータにアクセスできる
* クエリオプティマイザがクエリの実行順序やどのインデックスを使うかを判断してくれるため、アプリケーション開発者は気にしなくて良い
* そのため、ネットワークモデルと比較してリレーショナルモデルはデータモデルの修正が比較的容易

### リレーショナルデータベースとドキュメントデータベースの比較
※本章では、耐障害性や並列処理の扱いなどは扱わず、データモデルの違いについてみていく
* ドキュメントデータベースの利点
    * スキーマの柔軟性
    * ローカリティからくるパフォーマンス
    * アプリケーションのデータ構造との相似
* リレーショナルデータベースの利点
    * 結合や多対一、多対多の関係のサポート
    * （+トランザクションも）

#### アプリケーションのコードをシンプルにするデータモデルは？
* アプリケーションのデータ構造がドキュメントのような構造
    * →ドキュメントモデル
    * ドキュメントモデルの制約
        * ドキュメント内でネストされたアイテムは直接参照できない
        * ネストが深すぎない限り問題になることはない

#### ドキュメントモデルにおけるスキーマの柔軟性
* ドキュメントモデルはスキーマレスと言われる
    * 実際はそうではなくデータを読み取る際に何らかの構造を前提としている
    * 暗黙のうちにスキーマを想定しているが、DBがそれを強制しない

#### スキーマの対比
* スキーマオンリード(Schema on Read)
    * ドキュメントデータベースが使用
    * 動的型チェックに似ている
* スキーマオンライト(Schema on Write)
    * リレーショナルデータベースが使用
    * 静的型チェックに似ている
* スキーマを変更する際にRDBは問題になりやすい

#### ドキュメント、リレーショナルデータベースのハイブリッド
* リレーショナルデータベースがXMLやJSONをサポートするようになった
* ドキュメントデータベースでもリレーショナルな結合をクエリ言語でサポートするものが出てきた
* リレーショナルデータベースとドキュメントデータベースは類似性が高まっている


> [!NOTE]
> :memo:コメント
> 
> > しかし、ドキュメントのネストが深すぎない限り、通常これが問題になることはありません。
> - どのくらいのネストが良いかある程度感覚を掴まないと、どのようなケースでドキュメントデータベースを選択すればいいか判断が難しい。CODEの活動としてこうした検証してもいいかも(RyoyaC)
>
> > ポリグロットパーシステンス
>
> 初めて聞いた（Katsuya）
>


## 2.2：データのためのクエリ言語

### 命令的言語と宣言的言語
* 宣言的言語
    * SQLは宣言的
    * 宣言的言語では、求めるデータのパターン、つまり結果が満たすべき条件とデータをどのように変換（ソート、グループ化、集計）だけを指定し、どのようにその結果を得るかは指定しない
* 命令的言語
    * CODASYLは命令的
    * 命令的言語は、コンピュータに対して指定した操作を指定した順序で行うように指示する


### 宣言的言語の利点
* 命令的言語と比較して簡潔で扱いやすい
* DBエンジンの詳細を隠蔽してくれる
* 宣言的言語は並列実行に向いている
    * CPUの高速化はクロックの高速化ではなく、コア数の増加によって達成される
    * 命令型のコードでは特定の順序で実行されなければならない命令を指定するので並列化が難しくなるが、宣言的言語は結果のパターンだけを指定吸うので並列実行による高速化がやりやすい

### 宣言的と命令的の中間：MapReduce
* 大量のデータを多くのマシンにまたがってまとめて処理するプログラミングモデル
* MapReduceをサポートするNoSQL
    * MongoDB
    * CouchDB
* MapReduceは宣言的でも命令的でもなく中間に位置する
* 以下２つの組み合わせ
    * map(collectとも呼ばれる)
    * reduce(fold, injectとも呼ばれる)


> [!NOTE]
> :memo:コメント
> 
> 


## 2.3：グラフ型のデータモデル
未読
### グラフモデルの用語
* 頂点（ノード、エンティティ）
* 辺（エッジ、関係、弧）

### グラフモデルの例
* ソーシャルグラフ
* Webグラフ
* 道路や鉄道のネットワーク

### グラフモデルの種類
* プロパティグラフモデル
    * Neo4j
    * Titan
    * InifiniteGraph
* トリプルストアモデル
    * Datomic
    * AllegroGraph


> [!NOTE]
> :memo:コメント

## まとめ
> [!NOTE]
> :memo:コメント
>
> 以下整理のためのメモ(RyoyaC)
> * 最初は階層モデルで１つのツリーとして表現していた
> * 階層モデルでは、多対多の関係をうまく扱えなかったことからリレーショナルモデルが考案された
> * しかし、リレーショナルモデルでもあまり向いてないユースケースがでてきたため、NoSQLが広まった
> * ドキュメントデータベースは、ドキュメント間の関係がそれほど存在しないユースケースがターゲット
> * グラフデータベースはあらゆるもの同士に関係が存在するユースケースがターゲット
