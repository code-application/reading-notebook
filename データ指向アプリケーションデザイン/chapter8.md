# 第8章：分散システムの問題

### 本章の概要

### 前章までに出てきた分散システムの問題

### はじめに
* システムの異常処理に関するテーマを扱う
* レプリカのフェイルオーバーやレプリケーションラグ、トランザクションの並行性制御について論じた

### 楽観的な視点から悲観的な視点へ
* これまでの章では楽観的にシステムのフォールトについて論じてきた
* 現実はもっと厳しく、最大限に悲観的な視点が必要
* 「おかしくなるかもしれないことは必ずおかしくなる」と考える

### 分散システムの特性
* 単一コンピュータ用ソフトウェアと分散システムの違い
* 分散システムでは驚くべき問題が新たに大量に発生する

### エンジニアのタスク
* 問題が発生してもユーザーの期待に応えるシステムを構築することが目標
* 9章では分散システムでの保証を提供するアルゴリズムを紹介予定

### 本章の概要
* 分散システムで生じうる問題の悲観的な概要を提供
    * 8.2 信頼性の低いネットワーク
    * 8.3 信頼性の低いクロック
* これらの問題をどの程度回避できるかを論じる

### 問題の結果と対処法
* 問題の結果がシステムの状態を複雑にする
* 分散システムの状態の考え方や論理的な対処法を探る


> [!NOTE]
> 
> :memo:コメント
> 


---

## フォールトと部分障害

### 決定的処理と非決定的処理

### 単一コンピュータの特性

#### 予測可能な動作
* ソフトウェアはうまく動くか、動かないかのどちらか
* バグがあっても多くは再起動で修正可能

#### 決定的な処理
* 同じ処理は常に同じ結果を生成する

#### フォールト時の挙動
* ハードウェア問題では全体的な障害（カーネルパニック、ブルースクリーン）
* コンピュータは完全に動作するか、完全に壊れるかのどちらか

#### 設計の目的
* 間違った答えを返すよりはクラッシュする方が望ましい
* 理想的なシステムモデルを提示するよう設計されている

### 分散システムの特性

#### 根本的な違い
* 物理的な世界の現実に直面する必要がある

#### 部分障害
* システムの一部が破損することがあり得る
* 部分障害は非決定的であるため予測が困難

### 部分障害

### クラウドコンピューティングとスーパーコンピューティング

### 大規模コンピューティングシステムの構築哲学

#### 哲学のスペクトラム
* スーパーコンピュータ
    * 演算集中型タスク（気象予測、分子動力学）
    * 障害時にはジョブを停止し、チェックポイントから再開
    * 特化したハードウェアとネットワークトポロジー
* クラウドコンピューティング
    * 一般的なコンピュータ群、エラスティックリソース、オンデマンド課金
    * コモディティマシンを使用し、IPとイーサネットを基盤とする
    * 高い障害率を前提としつつ、価格を抑える

### インターネット上のシステム

### 大規模システムのフォールトトレランス

#### 常に何かが故障している前提
* 数千ノードのシステムでは常に故障が発生する

#### 耐障害性
* 障害ノードがあってもシステム全体が動作を継続することが重要
* ローリングアップグレードによるシステムの中断なく再起動
* 信頼性のないコンポーネントから信頼性のあるシステムを構築
### 部分障害の重要性

#### 設計の一部として考慮
* 小規模システムでも部分障害に対処する必要がある
* フォールト時の挙動を事前に知っておく
* 幅広いフォールトを考え、人為的にテスト環境で発生させる

### 疑念主義、悲観主義、偏執主義

#### テストの重要性
* フォールトが発生する前提でシステムを設計・運用する
* 分散システムではこれらの姿勢が割に合う


> [!NOTE]
> 
> :memo:コメント
> 


---

## 信頼性の低いネットワーク

### ネットワークのフォールトの実際

### ネットワークの信頼性の低さ
#### シェアードナッシングシステムの構築
* 大量のマシンがネットワークで接続される
* マシン間の通信手段はネットワークのみ

#### ネットワークの特性
* メッセージは非同期に送信される
* 到達性や到達時刻は保証されない

#### リクエストの問題
* 消失、待ち時間、リモートノードの障害など多様な可能性

#### 信頼性の要請
* フォールトに対処するための設計が必要
* システムはネットワーク障害に対処できるようになければならない

### フォールトの検出

#### フォールトの検出手段
* ロードバランサやシングルリーダーレプリケーションなどのシステム
* ノードが動作しているかの確認は難しい

#### 検出手段の限界
* TCPポートのクローズやICMPDestinationUnreachableパケットなど
* パケット到達の確認とリクエスト処理の関連性は不透明

### タイムアウトと限度のない遅延

#### 問題点
* タイムアウトは遅延フォールトを検出する重要な手段だが、その長さをどのように設定すべきかは明確な答えがない

#### タイムアウトの長さに関するジレンマ
* 長いタイムアウト
    * 遅延フォールトの発見まで時間がかかり、ユーザーは待たされるかエラーメッセージを見ることになる
* 短いタイムアウト
    * 一時的な速度低下などで誤ってノードが落ちていると見なすリスクが高まるまた、ノードが実際には生きており、処理が重複してしまう可能性がある

#### タイムアウト設定の難しさ
* ノードの状態に応じて、ネットワークとノードへの負荷が増減する
* 高負荷下で誤ったタイムアウトが設定されれば、問題を悪化させる可能性がある

#### 適切なタイムアウトの決定
* ネットワーク遅延の分布を観察し、アプリケーションの特性を考慮してトレードオフを決定する
* タイムアウトを自動的に調整する仕組みが望ましい（例 PhiAccrualfailuredetector）

### ネットワークの輻輳とキューイング
#### ネットワーク遅延の要因
* 複数のノードが同時にデータを送信する場合、キューイングにより遅延が発生する
* ネットワークリンクの輻輳やノードの負荷が増すと、遅延が増加する

#### TCPの影響
* TCPはフロー制御を行い、適切な送信レートを維持するためにキューイングを行う
* ネットワークやノードの負荷により、タイムアウトや再送が発生することで遅延が生じる

### 同期ネットワークと非同期ネットワーク
#### 同期ネットワークと非同期ネットワークの比較
* 同期ネットワークでは遅延が一定の最大値内に収まり、遅延が予測可能
* 非同期ネットワークでは遅延の上限がなく、遅延は変動する

#### ネットワーク設計の難しさ
* パケット交換方式のネットワークはバースト性のトラフィックに最適化されており、遅延の上限を持たない
* 回線交換方式のネットワークは遅延の上限を持つが、バースト性のトラフィックには適さない

#### QoSの有効性
* QoSを用いれば、パケット交換方式のネットワークで回線交換をエミュレートし、統計的に遅延の上限を課すことが可能
* しかし、現時点ではマルチテナントのデータセンターやパブリッククラウドでは有効ではない

#### 結論
* ネットワークの輻輳やキューイング、遅延の上限のなさを考慮し、適切なタイムアウトを経験的に決定するしかない


> [!NOTE]
> 
> :memo:コメント
> 


---

## 信頼性の低いクロック
* クロックの役割
    * アプリケーションはタイムアウト、レスポンスタイム、クエリ処理速度などの問いに答えるためにクロックに依存する
* 期間と時点の違い
    * クロックは期間（例：リクエストとレスポンスの間隔）と時点（特定の日付・時刻）の両方を計測する分散システムでは時刻の正確性が重要で、NTPがクロック同期を支援する

### 単調増加のクロックと時刻のクロック
* 時刻のクロック
    * カレンダーに基づいて現在時刻を提供NTPで同期されるが、閏秒の扱いやジャンプによる不確実性がある
* 単調増加のクロック
    * 期間の計測に用いられる各コンピュータの起動時からの経過時間を示し、システム間で比較することはできない

### クロックの同期と正確性
* クロックの不確実性
    * ハードウェアの振る舞いやNTPの制限により、クロックの正確性には限界があるネットワークの遅延や閏秒の影響もある
* 正確性の維持
    * GPSやPTPなどの技術によりクロック同期は可能だが、設定やファイアウォールの問題が影響を及ぼす可能性がある

### 同期クロックへの依存
#### 同期クロックの問題
* クロックの不正確さはしばしば気づかれず、ソフトウェアの頑健性に影響する
* クロックの不正確さはデータ損失やシステムの破綻を引き起こす可能性がある

#### クロックのモニタリング
* クロックのずれをモニタリングし、大きな変動があればクラスタから除外する
* モニタリングにより、重大な障害を未然に防げる

### 順序関係を持つイベントのタイムスタンプ

#### イベントの順序付け問題
* 複数ノードでのイベントの順序づけに関する問題を示す

#### 衝突解決戦略
* 最後の書き込みを優先する(LWW)戦略が広く使用されている
* LWWは因果関係の追跡を欠いており、データ損失のリスクがある

### クロックの信頼性と不確実性

#### クロックの信頼性
* 高分解能のクロック値は正確性が低いことが多い
* クロックの不確実性は信頼区間内の期間として考えるべき

#### 不確実性の計算
* システムのクロック不確実性は、クロックのソースと水晶発振器の同期からの経過時間によって影響を受ける

### グローバルなスナップショットのための同期クロック

#### スナップショット分離
* 小規模なトランザクションと長時間の読み取りのみトランザクションをサポートする重要な機能
* 読み取り専用トランザクションは一貫した状態でデータベースを見ることができ、ロックを妨げない

#### トランザクションIDの必要性
* スナップショット分離の最も一般的な実装には、単調増加するトランザクションIDが必要
* 分散システムでは、グローバルな単調増加するトランザクションIDの生成が困難

#### クロックの利用
* クロックのタイムスタンプをトランザクションIDとして使用する可能性があるが、正確性に疑問がある
* SpannerはTrueTimeAPIを使用してスナップショット分離を実装し、トランザクションの因果関係を保証

#### Spannerの仕組み
* 各データセンターにGPS受信機または原子時計を配備してクロックを同期
* トランザクションがコミットされる前に、信頼区間の長さだけ待機して因果関係を確保

#### 現状と課題
* 分散トランザクションの分野ではクロックの同期に関する研究が活発に行われているが、主流のデータベースにはまだ実装されていない

### プロセスの一時停止

#### クロックを利用したリーダー判定
* リーダーが書き込みを受け付けるため、ノードは自身がリーダーであり、安全に書き込みを処理できるかを知る必要がある
* リーダーが他のノードからリースを取得し、リースの有効期限を更新することで自身がリーダーであることを示す

#### 問題点
* コードはクロックの同期に依存しており、時刻のずれがあると正しく機能しない
* リクエストの処理にかかる時間を過大評価しており、一時停止による遅延を考慮していない

#### 一時停止の理由
* ガベージコレクション、仮想化環境によるサスペンド・レジューム、ディスクI/O待ちなど多岐にわたる
* これらの一時停止により、リースの有効期限を超える可能性がある

#### 分散システムにおけるスレッドセーフ
* 分散システムでは、共有メモリがなく、信頼できないネットワークを通じてメッセージを送信するため、従来のスレッドセーフの手法は適用できない

### 分散システムにおける一時停止の問題点

#### ノードの挙動の不確定性
* 一時停止が発生するかどうかやその期間が不明瞭であり、ノードは外界の動きに対応できない
* 一時停止中は反応がなく、他のノードから落ちたと見なされる可能性がある

#### リアルタイム性の保証
* 多くのプログラミング言語やオペレーティングシステムでは、一時停止の理由や期間が予測できない
* 物理的なデバイス制御システムでは、指定された時間内に反応を返さなければならない

### リアルタイムシステムの要件

#### 保証の提供
* リアルタイムオペレーティングシステム（RTOS）では、CPU時間の割り当てを保証するスケジューリングが必要
* ライブラリの関数は、最悪の実行時間に関する情報を提供する必要がある

#### コストと利用範囲
* リアルタイムシステムの開発には膨大なコストと時間がかかり、組み込みデバイスで主に使用される
* リアルタイム性の保証は、一般的なデータ処理システムでは経済的にも適切ではない

### ガベージコレクションによる影響の緩和

#### 柔軟なスケジューリング
* ランタイムはガベージコレクションのスケジュールに柔軟性を持たせることができる
* ガベージコレクションによる一時停止を短時間の予定された停止として扱う手法が提案されている

#### 一時停止の制御
* ランタイムがアプリケーションにガベージコレクションの予定を通知し、処理中のリクエストを待機させることで一時停止の影響を最小限に抑える
* 一部のシステムでは、長命なオブジェクトのたまりを防ぐためにプロセスを定期的に再起動する手法が用いられている

---

## 知識、真実、虚偽

### 真実は多数決で決定される
#### 非対称な障害によるネットワークの悪夢
* メッセージの送信に問題があるノードが他のノードから見られるかもしれない
* 障害が生じていると見なされるが、そのノードは実際には問題ない場合がある
* 長時間の一時停止により、他のノードから見れば落ちていると誤解されることもある

#### クオラムの利用
* クオラムにより、多数決に基づいてノードの状態が判断される
* クオラムを使うことで、システムは単一のノードの障害に耐えられる

### リーダーとロック
* システムでは一意性を保つ必要があるが、その実装には注意が必要
* リーダーは他のノードから見られるかもしれない
* フェンシングトークンを利用してリソースへのアクセスを保護する

#### リーダーの選出
* リーダーは障害などで降格されることがあり、ノード間の混乱を引き起こす可能性がある

#### フェンシングトークンの利用
* リソースへのアクセスを保護するために、フェンシングトークンを利用する
* サーバーサイドでのトークンのチェックは、クライアントの誤動作からサービスを保護するために必要

### ビザンチン障害

#### ビザンチン障害の認識と概要
* ビザンチン障害フェンシングトークンは、意図せず誤った動作をするノードを検出し、ブロックする
* ビザンチン障害は、意図的にシステムの保証を損なおうとするノードによって引き起こされる
* 信頼できないが誠実なノードを前提としている

#### ビザンチン耐性の重要性
* ビザンチン耐性は、ノードの不具合や攻撃にも正しく機能し続ける能力を指す
* 航空宇宙産業などの環境では、放射線や他のノードの攻撃によってシステムが損傷するリスクがある
* 参加者が競争的な状況にあるシステムでは、他のノードが悪意を持ってメッセージを送信する可能性がある
* ピアツーピアのネットワークやブロックチェーンなど、中央集権的な機関が不在な環境ではビザンチン耐性が特に重要

#### ビザンチン耐性の実装上の課題
* ビザンチン耐性を持たせるためのプロトコルは複雑であり、組み込みシステムはハードウェアレベルのサポートに依存している
* 多くのサーバーサイドデータシステムでは、コストが現実的ではない
* Webアプリケーションなどのクライアント制御下のシステムでは、クライアントの悪意ある行動に対処するためのセキュリティ対策が重要

#### 弱い嘘ノードへの対処
* 弱い「嘘」に対する保護の仕組みをソフトウェアに組み込むことで、信頼性を向上させる
* 例えば、ハードウェアの問題やソフトウェアのバグによるメッセージの破損に対処する方法がある
* ユーザーからの入力を慎重に検証し、サービスへのアクセスを適切に制限することで、セキュリティを向上させることが可能

### システムモデルと現実

#### システムモデルの定義
* 分散システムのアルゴリズムは、現実のフォールトに対する耐性が必要
* システムモデルは、アルゴリズムの前提を抽象化して定義する

#### システムモデルのタイミング
* 同期モデル
    * ネットワーク遅延やプロセスの停止、クロックの誤差に上限があると仮定
* 部分同期モデル
    * 大部分は同期モデルに従うが、時折制約を超えるフォールトが生じる
* 非同期モデル
    * タイミングの前提を許可せず、厳しい制約下でアルゴリズムを設計

#### ノード障害のモデル
* クラッシュストップフォールト
    * ノードはクラッシュするか完全に失われる
* クラッシュリカバリフォールト
    * ノードは再びレスポンスを返す可能性がある
* ビザンチン（任意）障害
    * ノードの行動が予測不能で欺瞞的である

#### アルゴリズムの正しさ
* 正しさの定義 アルゴリズムが満たすべき性質を定義することにより定義される
* 安全性とライブ性 安全性は悪いことが起こらないこと、ライブ性は最終的に良いことが生じることを示す

#### 安全性とライブ性の違い
* 安全性 違反が生じた場合に指摘可能で、修復不可能
* ライブ性 違反が将来的に修復される可能性がある

#### 現実世界へのシステムモデルのマッピング
* 抽象化と現実のギャップ 現実のシステムは抽象モデルとは異なる複雑さを持つ
* 問題の顕在化 理論的なアルゴリズムは、実装段階で問題が浮き彫りになる可能性がある

#### 理論と実践の重要性
* 理論的な分析と実践的なテストは、アルゴリズムの正しさを確認するために必要


> [!NOTE]
> 
> :memo:コメント
> 


---

## まとめ
* 分散システムにはさまざまな問題がありますパケットのロストや遅延、レスポンスのロストや遅延、クロックのずれ、プロセスの一時停止などが挙げられます
* 分散システムは部分障害に耐える必要がありますフォールトの検出が困難であり、ノードの状態を正確に把握することが難しいため、多くの場合、タイムアウトが使用されます
* マシン間にはグローバルな変数や共有メモリがないため、ノード間で情報をやり取りする唯一の方法は、信頼性の低いネットワークを介してですこのため、クオラムや合意プロトコルが重要です
* 分散システムの現実は、単一のコンピュータ上での理想化されたプログラミングとは異なりますエンジニアは、単一のコンピュータ上では簡単に解決できる問題でも、分散システムでは複雑さが増すことを認識する必要があります
* 分散システムは、スケーラビリティ、耐障害性、低レイテンシなどの利点がありますが、高信頼性を確保することは難しい場合もあります
* 分散システムはサービスレベルで中断することなく、問題のあるノードを個別に処理できるため、スーパーコンピュータとは異なる特性があります
* 次章では、これらの問題に対処するためのアルゴリズムに焦点を当てます